Auto generated patch. Do not edit or delete it, even if empty.
diff -ruN --strip-trailing-cr a/clang/include/clang/Driver/Options.td b/clang/include/clang/Driver/Options.td
--- a/clang/include/clang/Driver/Options.td
+++ b/clang/include/clang/Driver/Options.td
@@ -1786,12 +1786,6 @@
   PosFlag<SetTrue, [], [ClangOption, CC1Option],
           "Emit extra debug info to make sample profile more accurate">,
   NegFlag<SetFalse>>;
-def fprofile_generate_cold_function_coverage : Flag<["-"], "fprofile-generate-cold-function-coverage">, 
-    Group<f_Group>, Visibility<[ClangOption, CLOption]>,
-    HelpText<"Generate instrumented code to collect coverage info for cold functions into default.profraw file (overridden by '=' form of option or LLVM_PROFILE_FILE env var)">;
-def fprofile_generate_cold_function_coverage_EQ : Joined<["-"], "fprofile-generate-cold-function-coverage=">, 
-    Group<f_Group>, Visibility<[ClangOption, CLOption]>, MetaVarName<"<directory>">,
-    HelpText<"Generate instrumented code to collect coverage info for cold functions into <directory>/default.profraw (overridden by LLVM_PROFILE_FILE env var)">; 
 def fprofile_instr_generate : Flag<["-"], "fprofile-instr-generate">,
     Group<f_Group>, Visibility<[ClangOption, CLOption]>,
     HelpText<"Generate instrumented code to collect execution counts into default.profraw file (overridden by '=' form of option or LLVM_PROFILE_FILE env var)">;
diff -ruN --strip-trailing-cr a/clang/lib/Driver/ToolChain.cpp b/clang/lib/Driver/ToolChain.cpp
--- a/clang/lib/Driver/ToolChain.cpp
+++ b/clang/lib/Driver/ToolChain.cpp
@@ -899,9 +899,7 @@
          Args.hasArg(options::OPT_fprofile_instr_generate) ||
          Args.hasArg(options::OPT_fprofile_instr_generate_EQ) ||
          Args.hasArg(options::OPT_fcreate_profile) ||
-         Args.hasArg(options::OPT_forder_file_instrumentation) ||
-         Args.hasArg(options::OPT_fprofile_generate_cold_function_coverage) ||
-         Args.hasArg(options::OPT_fprofile_generate_cold_function_coverage_EQ);
+         Args.hasArg(options::OPT_forder_file_instrumentation);
 }
 
 bool ToolChain::needsGCovInstrumentation(const llvm::opt::ArgList &Args) {
diff -ruN --strip-trailing-cr a/clang/lib/Driver/ToolChains/Clang.cpp b/clang/lib/Driver/ToolChains/Clang.cpp
--- a/clang/lib/Driver/ToolChains/Clang.cpp
+++ b/clang/lib/Driver/ToolChains/Clang.cpp
@@ -632,26 +632,6 @@
     }
   }
 
-  if (auto *ColdFuncCoverageArg = Args.getLastArg(
-          options::OPT_fprofile_generate_cold_function_coverage,
-          options::OPT_fprofile_generate_cold_function_coverage_EQ)) {
-    SmallString<128> Path(
-        ColdFuncCoverageArg->getOption().matches(
-            options::OPT_fprofile_generate_cold_function_coverage_EQ)
-            ? ColdFuncCoverageArg->getValue()
-            : "");
-    llvm::sys::path::append(Path, "default_%m.profraw");
-    // FIXME: Idealy the file path should be passed through
-    // `-fprofile-instrument-path=`(InstrProfileOutput), however, this field is
-    // shared with other profile use path(see PGOOptions), we need to refactor
-    // PGOOptions to make it work.
-    CmdArgs.push_back("-mllvm");
-    CmdArgs.push_back(Args.MakeArgString(
-        Twine("--instrument-cold-function-only-path=") + Path));
-    CmdArgs.push_back("-mllvm");
-    CmdArgs.push_back("--pgo-function-entry-coverage");
-  }
-
   Arg *PGOGenArg = nullptr;
   if (PGOGenerateArg) {
     assert(!CSPGOGenerateArg);
diff -ruN --strip-trailing-cr a/clang/test/CodeGen/pgo-cold-function-coverage.c b/clang/test/CodeGen/pgo-cold-function-coverage.c
--- a/clang/test/CodeGen/pgo-cold-function-coverage.c
+++ b/clang/test/CodeGen/pgo-cold-function-coverage.c
@@ -1,19 +0,0 @@
-// Test -fprofile-generate-cold-function-coverage 
-
-// RUN: rm -rf %t && split-file %s %t
-// RUN: %clang --target=x86_64 -O2 -fprofile-generate-cold-function-coverage=/xxx/yyy/ -fprofile-sample-accurate -fprofile-sample-use=%t/pgo-cold-func.prof  -S -emit-llvm -o - %t/pgo-cold-func.c | FileCheck %s
-
-// CHECK: @__llvm_profile_filename = {{.*}} c"/xxx/yyy/default_%m.profraw\00"
-
-// CHECK: store i8 0, ptr @__profc_bar, align 1
-// CHECK-NOT: @__profc_foo 
-
-//--- pgo-cold-func.prof
-foo:1:1
- 1: 1
-
-//--- pgo-cold-func.c
-int bar(int x) { return x;}
-int foo(int x) { 
-    return x;
-}
diff -ruN --strip-trailing-cr a/clang/test/Driver/fprofile-generate-cold-function-coverage.c b/clang/test/Driver/fprofile-generate-cold-function-coverage.c
--- a/clang/test/Driver/fprofile-generate-cold-function-coverage.c
+++ b/clang/test/Driver/fprofile-generate-cold-function-coverage.c
@@ -1,8 +0,0 @@
-// RUN: %clang -### -c -fprofile-generate-cold-function-coverage %s 2>&1 | FileCheck %s
-// CHECK: "--instrument-cold-function-only-path=default_%m.profraw" 
-// CHECK: "--pgo-function-entry-coverage"
-// CHECK-NOT:  "-fprofile-instrument"
-// CHECK-NOT:  "-fprofile-instrument-path=
-
-// RUN: %clang -### -c -fprofile-generate-cold-function-coverage=dir %s 2>&1 | FileCheck %s --check-prefix=CHECK-EQ
-// CHECK-EQ: "--instrument-cold-function-only-path=dir{{/|\\\\}}default_%m.profraw" 
diff -ruN --strip-trailing-cr a/libc/test/UnitTest/LibcTest.h b/libc/test/UnitTest/LibcTest.h
--- a/libc/test/UnitTest/LibcTest.h
+++ b/libc/test/UnitTest/LibcTest.h
@@ -165,7 +165,7 @@
   // Helper to allow macro invocations like `ASSERT_EQ(foo, nullptr)`.
   template <typename ValType,
             cpp::enable_if_t<cpp::is_pointer_v<ValType>, ValType> = nullptr>
-  bool test(TestCond Cond, ValType LHS, std::nullptr_t, const char *LHSStr,
+  bool test(TestCond Cond, ValType LHS, cpp::nullptr_t, const char *LHSStr,
             const char *RHSStr, internal::Location Loc) {
     return test(Cond, LHS, static_cast<ValType>(nullptr), LHSStr, RHSStr, Loc);
   }
diff -ruN --strip-trailing-cr a/llvm/include/llvm/Support/NVPTXAddrSpace.h b/llvm/include/llvm/Support/NVPTXAddrSpace.h
--- a/llvm/include/llvm/Support/NVPTXAddrSpace.h
+++ b/llvm/include/llvm/Support/NVPTXAddrSpace.h
@@ -1,33 +0,0 @@
-//===---------------- NVPTXAddrSpace.h -------------------------*- C++ -*-===//
-//
-// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
-// See https://llvm.org/LICENSE.txt for license information.
-// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
-//
-//===----------------------------------------------------------------------===//
-//
-/// \file
-/// NVPTX address space definition
-///
-//
-//===----------------------------------------------------------------------===//
-
-#ifndef LLVM_SUPPORT_NVPTXADDRSPACE_H
-#define LLVM_SUPPORT_NVPTXADDRSPACE_H
-
-namespace llvm {
-namespace NVPTXAS {
-enum AddressSpace : unsigned {
-  ADDRESS_SPACE_GENERIC = 0,
-  ADDRESS_SPACE_GLOBAL = 1,
-  ADDRESS_SPACE_SHARED = 3,
-  ADDRESS_SPACE_CONST = 4,
-  ADDRESS_SPACE_LOCAL = 5,
-
-  ADDRESS_SPACE_PARAM = 101,
-};
-} // end namespace NVPTXAS
-
-} // end namespace llvm
-
-#endif // LLVM_SUPPORT_NVPTXADDRSPACE_H
diff -ruN --strip-trailing-cr a/llvm/lib/Passes/PassBuilderPipelines.cpp b/llvm/lib/Passes/PassBuilderPipelines.cpp
--- a/llvm/lib/Passes/PassBuilderPipelines.cpp
+++ b/llvm/lib/Passes/PassBuilderPipelines.cpp
@@ -296,12 +296,7 @@
     "enable-loop-versioning-licm", cl::init(false), cl::Hidden,
     cl::desc("Enable the experimental Loop Versioning LICM pass"));
 
-static cl::opt<std::string> InstrumentColdFuncOnlyPath(
-    "instrument-cold-function-only-path", cl::init(""),
-    cl::desc("File path for cold function only instrumentation"), cl::Hidden);
-
 extern cl::opt<std::string> UseCtxProfile;
-extern cl::opt<bool> PGOInstrumentColdFunctionOnly;
 
 namespace llvm {
 extern cl::opt<bool> EnableMemProfContextDisambiguation;
@@ -1187,13 +1182,8 @@
   const bool IsCtxProfUse =
       !UseCtxProfile.empty() && Phase == ThinOrFullLTOPhase::ThinLTOPreLink;
 
-  // Enable cold function coverage instrumentation if
-  // InstrumentColdFuncOnlyPath is provided.
-  const bool IsColdFuncOnlyInstrGen = PGOInstrumentColdFunctionOnly =
-      IsPGOPreLink && !InstrumentColdFuncOnlyPath.empty();
-
   if (IsPGOInstrGen || IsPGOInstrUse || IsMemprofUse || IsCtxProfGen ||
-      IsCtxProfUse || IsColdFuncOnlyInstrGen)
+      IsCtxProfUse)
     addPreInlinerPasses(MPM, Level, Phase);
 
   // Add all the requested passes for instrumentation PGO, if requested.
@@ -1215,11 +1205,6 @@
       return MPM;
     addPostPGOLoopRotation(MPM, Level);
     MPM.addPass(PGOCtxProfLoweringPass());
-  } else if (IsColdFuncOnlyInstrGen) {
-    addPGOInstrPasses(
-        MPM, Level, /* RunProfileGen */ true, /* IsCS */ false,
-        /* AtomicCounterUpdate */ false, InstrumentColdFuncOnlyPath,
-        /* ProfileRemappingFile */ "", IntrusiveRefCntPtr<vfs::FileSystem>());
   }
 
   if (IsPGOInstrGen || IsPGOInstrUse || IsCtxProfGen)
diff -ruN --strip-trailing-cr a/llvm/lib/Target/NVPTX/MCTargetDesc/NVPTXBaseInfo.h b/llvm/lib/Target/NVPTX/MCTargetDesc/NVPTXBaseInfo.h
--- a/llvm/lib/Target/NVPTX/MCTargetDesc/NVPTXBaseInfo.h
+++ b/llvm/lib/Target/NVPTX/MCTargetDesc/NVPTXBaseInfo.h
@@ -16,10 +16,18 @@
 #ifndef LLVM_LIB_TARGET_NVPTX_MCTARGETDESC_NVPTXBASEINFO_H
 #define LLVM_LIB_TARGET_NVPTX_MCTARGETDESC_NVPTXBASEINFO_H
 
-#include "llvm/Support/NVPTXAddrSpace.h"
 namespace llvm {
 
-using namespace NVPTXAS;
+enum AddressSpace {
+  ADDRESS_SPACE_GENERIC = 0,
+  ADDRESS_SPACE_GLOBAL = 1,
+  ADDRESS_SPACE_SHARED = 3,
+  ADDRESS_SPACE_CONST = 4,
+  ADDRESS_SPACE_LOCAL = 5,
+
+  // NVVM Internal
+  ADDRESS_SPACE_PARAM = 101
+};
 
 namespace NVPTXII {
 enum {
diff -ruN --strip-trailing-cr a/llvm/lib/Target/NVPTX/NVPTXTargetTransformInfo.cpp b/llvm/lib/Target/NVPTX/NVPTXTargetTransformInfo.cpp
--- a/llvm/lib/Target/NVPTX/NVPTXTargetTransformInfo.cpp
+++ b/llvm/lib/Target/NVPTX/NVPTXTargetTransformInfo.cpp
@@ -15,12 +15,10 @@
 #include "llvm/CodeGen/CostTable.h"
 #include "llvm/CodeGen/TargetLowering.h"
 #include "llvm/IR/Constants.h"
-#include "llvm/IR/IntrinsicInst.h"
 #include "llvm/IR/Intrinsics.h"
 #include "llvm/IR/IntrinsicsNVPTX.h"
 #include "llvm/IR/Value.h"
 #include "llvm/Support/Casting.h"
-#include "llvm/Support/ErrorHandling.h"
 #include "llvm/Transforms/InstCombine/InstCombiner.h"
 #include <optional>
 using namespace llvm;
@@ -119,8 +117,7 @@
 }
 
 // Convert NVVM intrinsics to target-generic LLVM code where possible.
-static Instruction *convertNvvmIntrinsicToLlvm(InstCombiner &IC,
-                                               IntrinsicInst *II) {
+static Instruction *simplifyNvvmIntrinsic(IntrinsicInst *II, InstCombiner &IC) {
   // Each NVVM intrinsic we can simplify can be replaced with one of:
   //
   //  * an LLVM intrinsic,
@@ -416,65 +413,11 @@
   llvm_unreachable("All SpecialCase enumerators should be handled in switch.");
 }
 
-// Returns an instruction pointer (may be nullptr if we do not know the answer).
-// Returns nullopt if `II` is not one of the `isspacep` intrinsics.
-static std::optional<Instruction *>
-handleSpaceCheckIntrinsics(InstCombiner &IC, IntrinsicInst &II) {
-  Value *Op0 = II.getArgOperand(0);
-  // Returns true/false when we know the answer, nullopt otherwise.
-  auto CheckASMatch = [](unsigned IID, unsigned AS) -> std::optional<bool> {
-    if (AS == NVPTXAS::ADDRESS_SPACE_GENERIC ||
-        AS == NVPTXAS::ADDRESS_SPACE_PARAM)
-      return std::nullopt; // Got to check at run-time.
-    switch (IID) {
-    case Intrinsic::nvvm_isspacep_global:
-      return AS == NVPTXAS::ADDRESS_SPACE_GLOBAL;
-    case Intrinsic::nvvm_isspacep_local:
-      return AS == NVPTXAS::ADDRESS_SPACE_LOCAL;
-    case Intrinsic::nvvm_isspacep_shared:
-      return AS == NVPTXAS::ADDRESS_SPACE_SHARED;
-    case Intrinsic::nvvm_isspacep_shared_cluster:
-      // We can't tell shared from shared_cluster at compile time from AS alone,
-      // but it can't be either is AS is not shared.
-      return AS == NVPTXAS::ADDRESS_SPACE_SHARED ? std::nullopt
-                                                 : std::optional{false};
-    case Intrinsic::nvvm_isspacep_const:
-      return AS == NVPTXAS::ADDRESS_SPACE_CONST;
-    default:
-      llvm_unreachable("Unexpected intrinsic");
-    }
-  };
-
-  switch (auto IID = II.getIntrinsicID()) {
-  case Intrinsic::nvvm_isspacep_global:
-  case Intrinsic::nvvm_isspacep_local:
-  case Intrinsic::nvvm_isspacep_shared:
-  case Intrinsic::nvvm_isspacep_shared_cluster:
-  case Intrinsic::nvvm_isspacep_const: {
-    auto *Ty = II.getType();
-    unsigned AS = Op0->getType()->getPointerAddressSpace();
-    // Peek through ASC to generic AS.
-    // TODO: we could dig deeper through both ASCs and GEPs.
-    if (AS == NVPTXAS::ADDRESS_SPACE_GENERIC)
-      if (auto *ASCO = dyn_cast<AddrSpaceCastOperator>(Op0))
-        AS = ASCO->getOperand(0)->getType()->getPointerAddressSpace();
-
-    if (std::optional<bool> Answer = CheckASMatch(IID, AS))
-      return IC.replaceInstUsesWith(II, ConstantInt::get(Ty, *Answer));
-    return nullptr; // Don't know the answer, got to check at run time.
-  }
-  default:
-    return std::nullopt;
-  }
-}
-
 std::optional<Instruction *>
 NVPTXTTIImpl::instCombineIntrinsic(InstCombiner &IC, IntrinsicInst &II) const {
-  if (std::optional<Instruction *> I = handleSpaceCheckIntrinsics(IC, II))
-    return *I;
-  if (Instruction *I = convertNvvmIntrinsicToLlvm(IC, &II))
+  if (Instruction *I = simplifyNvvmIntrinsic(&II, IC)) {
     return I;
-
+  }
   return std::nullopt;
 }
 
diff -ruN --strip-trailing-cr a/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp b/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp
--- a/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp
+++ b/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp
@@ -319,20 +319,6 @@
     cl::desc("Do not instrument functions with the number of critical edges "
              " greater than this threshold."));
 
-static cl::opt<uint64_t> PGOColdInstrumentEntryThreshold(
-    "pgo-cold-instrument-entry-threshold", cl::init(0), cl::Hidden,
-    cl::desc("For cold function instrumentation, skip instrumenting functions "
-             "whose entry count is above the given value."));
-
-static cl::opt<bool> PGOTreatUnknownAsCold(
-    "pgo-treat-unknown-as-cold", cl::init(false), cl::Hidden,
-    cl::desc("For cold function instrumentation, treat count unknown(e.g. "
-             "unprofiled) functions as cold."));
-
-cl::opt<bool> PGOInstrumentColdFunctionOnly(
-    "pgo-instrument-cold-function-only", cl::init(false), cl::Hidden,
-    cl::desc("Enable cold function only instrumentation."));
-
 extern cl::opt<unsigned> MaxNumVTableAnnotations;
 
 namespace llvm {
@@ -1911,11 +1897,6 @@
     return true;
   if (F.getInstructionCount() < PGOFunctionSizeThreshold)
     return true;
-  if (PGOInstrumentColdFunctionOnly) {
-    if (auto EntryCount = F.getEntryCount())
-      return EntryCount->getCount() > PGOColdInstrumentEntryThreshold;
-    return !PGOTreatUnknownAsCold;
-  }
   return false;
 }
 
diff -ruN --strip-trailing-cr a/llvm/test/Transforms/InstCombine/NVPTX/isspacep.ll b/llvm/test/Transforms/InstCombine/NVPTX/isspacep.ll
--- a/llvm/test/Transforms/InstCombine/NVPTX/isspacep.ll
+++ b/llvm/test/Transforms/InstCombine/NVPTX/isspacep.ll
@@ -1,277 +0,0 @@
-; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 5
-; RUN: opt < %s -passes=instcombine -mtriple=nvptx64-nvidia-cuda -S | FileCheck %s
-target datalayout = "e-i64:64-i128:128-v16:16-v32:32-n16:32:64"
-target triple = "nvptx64-nvidia-cuda"
-
-; Source data in different AS.
-@shared_data = dso_local addrspace(3) global i32 undef, align 4
-@global_data = dso_local addrspace(1) externally_initialized global i32 0, align 4
-@const_data = dso_local addrspace(4) externally_initialized constant i32 3, align 4
-
-; Results get stored here.
-@gen = dso_local addrspace(1) externally_initialized global i8 0, align 1
-@g1 = dso_local addrspace(1) externally_initialized global i8 0, align 1
-@g2 = dso_local addrspace(1) externally_initialized global i8 0, align 1
-@s1 = dso_local addrspace(1) externally_initialized global i8 0, align 1
-@s2 = dso_local addrspace(1) externally_initialized global i8 0, align 1
-@c1 = dso_local addrspace(1) externally_initialized global i8 0, align 1
-@c2 = dso_local addrspace(1) externally_initialized global i8 0, align 1
-@l = dso_local addrspace(1) externally_initialized global i8 0, align 1
-
-declare i1 @llvm.nvvm.isspacep.global(ptr nocapture)
-declare i1 @llvm.nvvm.isspacep.shared(ptr nocapture)
-declare i1 @llvm.nvvm.isspacep.const(ptr nocapture)
-declare i1 @llvm.nvvm.isspacep.local(ptr nocapture)
-
-define dso_local void @check_global(ptr nocapture noundef readnone %out, ptr nocapture noundef readnone %genp,
-; CHECK-LABEL: define dso_local void @check_global(
-; CHECK-SAME: ptr nocapture noundef readnone [[OUT:%.*]], ptr nocapture noundef readnone [[GENP:%.*]], ptr addrspace(1) [[GP:%.*]], ptr addrspace(3) [[SP:%.*]], ptr addrspace(4) [[CP:%.*]], ptr addrspace(5) [[LP:%.*]]) local_unnamed_addr {
-; CHECK-NEXT:  [[ENTRY:.*:]]
-; CHECK-NEXT:    [[GEN0:%.*]] = tail call i1 @llvm.nvvm.isspacep.global(ptr [[GENP]])
-; CHECK-NEXT:    [[STOREDV:%.*]] = zext i1 [[GEN0]] to i8
-; CHECK-NEXT:    store i8 [[STOREDV]], ptr addrspacecast (ptr addrspace(1) @gen to ptr), align 1
-; CHECK-NEXT:    store i8 1, ptr addrspacecast (ptr addrspace(1) @g1 to ptr), align 1
-; CHECK-NEXT:    store i8 1, ptr addrspacecast (ptr addrspace(1) @g2 to ptr), align 1
-; CHECK-NEXT:    store i8 0, ptr addrspacecast (ptr addrspace(1) @s1 to ptr), align 1
-; CHECK-NEXT:    store i8 0, ptr addrspacecast (ptr addrspace(1) @s2 to ptr), align 1
-; CHECK-NEXT:    store i8 0, ptr addrspacecast (ptr addrspace(1) @c1 to ptr), align 1
-; CHECK-NEXT:    store i8 0, ptr addrspacecast (ptr addrspace(1) @c2 to ptr), align 1
-; CHECK-NEXT:    store i8 0, ptr addrspacecast (ptr addrspace(1) @l to ptr), align 1
-; CHECK-NEXT:    ret void
-;
-  ptr addrspace(1) %gp,
-  ptr addrspace(3) %sp,
-  ptr addrspace(4) %cp,
-  ptr addrspace(5) %lp) local_unnamed_addr {
-entry:
-  ; No constant folding for generic pointers of unknown origin.
-  %gen0 = tail call i1 @llvm.nvvm.isspacep.global(ptr %genp)
-  %storedv = zext i1 %gen0 to i8
-  store i8 %storedv, ptr addrspacecast (ptr addrspace(1) @gen to ptr), align 1
-
-  %isg1 = tail call i1 @llvm.nvvm.isspacep.global(ptr addrspacecast (ptr addrspace(1) @global_data to ptr))
-  %isg18 = zext i1 %isg1 to i8
-  store i8 %isg18, ptr addrspacecast (ptr addrspace(1) @g1 to ptr), align 1
-
-  %gp_asc = addrspacecast ptr addrspace(1) %gp to ptr
-  %isg2 = tail call i1 @llvm.nvvm.isspacep.global(ptr %gp_asc)
-  %isg28 = zext i1 %isg2 to i8
-  store i8 %isg28, ptr addrspacecast (ptr addrspace(1) @g2 to ptr), align 1
-
-  %iss1 = tail call i1 @llvm.nvvm.isspacep.global(ptr addrspacecast (ptr addrspace(3) @shared_data to ptr))
-  %iss18 = zext i1 %iss1 to i8
-  store i8 %iss18, ptr addrspacecast (ptr addrspace(1) @s1 to ptr), align 1
-
-  %sp_asc = addrspacecast ptr addrspace(3) %sp to ptr
-  %iss2 = tail call i1 @llvm.nvvm.isspacep.global(ptr %sp_asc)
-  %iss28 = zext i1 %iss2 to i8
-  store i8 %iss28, ptr addrspacecast (ptr addrspace(1) @s2 to ptr), align 1
-
-  %isc1 = tail call i1 @llvm.nvvm.isspacep.global(ptr addrspacecast (ptr addrspace(4) @const_data to ptr))
-  %isc18 = zext i1 %isc1 to i8
-  store i8 %isc18, ptr addrspacecast (ptr addrspace(1) @c1 to ptr), align 1
-
-  %cp_asc = addrspacecast ptr addrspace(4) %cp to ptr
-  %isc2 = tail call i1 @llvm.nvvm.isspacep.global(ptr %cp_asc)
-  %isc28 = zext i1 %isc2 to i8
-  store i8 %isc28, ptr addrspacecast (ptr addrspace(1) @c2 to ptr), align 1
-
-  ; Local data can't ihave a constant address, so we can't have a constant ASC expression
-  ; We can only use an ASC instruction.
-  %lp_asc = addrspacecast ptr addrspace(5) %lp to ptr
-  %isl = call i1 @llvm.nvvm.isspacep.global(ptr nonnull %lp_asc)
-  %isl8 = zext i1 %isl to i8
-  store i8 %isl8, ptr addrspacecast (ptr addrspace(1) @l to ptr), align 1
-
-  ret void
-}
-
-define dso_local void @check_shared(ptr nocapture noundef readnone %out, ptr nocapture noundef readnone %genp,
-; CHECK-LABEL: define dso_local void @check_shared(
-; CHECK-SAME: ptr nocapture noundef readnone [[OUT:%.*]], ptr nocapture noundef readnone [[GENP:%.*]], ptr addrspace(1) [[GP:%.*]], ptr addrspace(3) [[SP:%.*]], ptr addrspace(4) [[CP:%.*]], ptr addrspace(5) [[LP:%.*]]) local_unnamed_addr {
-; CHECK-NEXT:  [[ENTRY:.*:]]
-; CHECK-NEXT:    [[GEN0:%.*]] = tail call i1 @llvm.nvvm.isspacep.shared(ptr [[GENP]])
-; CHECK-NEXT:    [[STOREDV:%.*]] = zext i1 [[GEN0]] to i8
-; CHECK-NEXT:    store i8 [[STOREDV]], ptr addrspacecast (ptr addrspace(1) @gen to ptr), align 1
-; CHECK-NEXT:    store i8 0, ptr addrspacecast (ptr addrspace(1) @g1 to ptr), align 1
-; CHECK-NEXT:    store i8 0, ptr addrspacecast (ptr addrspace(1) @g2 to ptr), align 1
-; CHECK-NEXT:    store i8 1, ptr addrspacecast (ptr addrspace(1) @s1 to ptr), align 1
-; CHECK-NEXT:    store i8 1, ptr addrspacecast (ptr addrspace(1) @s2 to ptr), align 1
-; CHECK-NEXT:    store i8 0, ptr addrspacecast (ptr addrspace(1) @c1 to ptr), align 1
-; CHECK-NEXT:    store i8 0, ptr addrspacecast (ptr addrspace(1) @c2 to ptr), align 1
-; CHECK-NEXT:    store i8 0, ptr addrspacecast (ptr addrspace(1) @l to ptr), align 1
-; CHECK-NEXT:    ret void
-;
-  ptr addrspace(1) %gp,
-  ptr addrspace(3) %sp,
-  ptr addrspace(4) %cp,
-  ptr addrspace(5) %lp) local_unnamed_addr {
-entry:
-  ; No constant folding for generic pointers of unknown origin.
-  %gen0 = tail call i1 @llvm.nvvm.isspacep.shared(ptr %genp)
-  %storedv = zext i1 %gen0 to i8
-  store i8 %storedv, ptr addrspacecast (ptr addrspace(1) @gen to ptr), align 1
-
-  %isg1 = tail call i1 @llvm.nvvm.isspacep.shared(ptr addrspacecast (ptr addrspace(1) @global_data to ptr))
-  %isg18 = zext i1 %isg1 to i8
-  store i8 %isg18, ptr addrspacecast (ptr addrspace(1) @g1 to ptr), align 1
-
-  %gp_asc = addrspacecast ptr addrspace(1) %gp to ptr
-  %isg2 = tail call i1 @llvm.nvvm.isspacep.shared(ptr %gp_asc)
-  %isg28 = zext i1 %isg2 to i8
-  store i8 %isg28, ptr addrspacecast (ptr addrspace(1) @g2 to ptr), align 1
-
-  %iss1 = tail call i1 @llvm.nvvm.isspacep.shared(ptr addrspacecast (ptr addrspace(3) @shared_data to ptr))
-  %iss18 = zext i1 %iss1 to i8
-  store i8 %iss18, ptr addrspacecast (ptr addrspace(1) @s1 to ptr), align 1
-
-  %sp_asc = addrspacecast ptr addrspace(3) %sp to ptr
-  %iss2 = tail call i1 @llvm.nvvm.isspacep.shared(ptr %sp_asc)
-  %iss28 = zext i1 %iss2 to i8
-  store i8 %iss28, ptr addrspacecast (ptr addrspace(1) @s2 to ptr), align 1
-
-  %isc1 = tail call i1 @llvm.nvvm.isspacep.shared(ptr addrspacecast (ptr addrspace(4) @const_data to ptr))
-  %isc18 = zext i1 %isc1 to i8
-  store i8 %isc18, ptr addrspacecast (ptr addrspace(1) @c1 to ptr), align 1
-
-  %cp_asc = addrspacecast ptr addrspace(4) %cp to ptr
-  %isc2 = tail call i1 @llvm.nvvm.isspacep.shared(ptr %cp_asc)
-  %isc28 = zext i1 %isc2 to i8
-  store i8 %isc28, ptr addrspacecast (ptr addrspace(1) @c2 to ptr), align 1
-
-  ; Local data can't have a constant address, so we can't have a constant ASC expression
-  ; We can only use an ASC instruction.
-  %lp_asc = addrspacecast ptr addrspace(5) %lp to ptr
-  %isl = call i1 @llvm.nvvm.isspacep.shared(ptr nonnull %lp_asc)
-  %isl8 = zext i1 %isl to i8
-  store i8 %isl8, ptr addrspacecast (ptr addrspace(1) @l to ptr), align 1
-
-  ret void
-}
-
-define dso_local void @check_const(ptr nocapture noundef readnone %out, ptr nocapture noundef readnone %genp,
-; CHECK-LABEL: define dso_local void @check_const(
-; CHECK-SAME: ptr nocapture noundef readnone [[OUT:%.*]], ptr nocapture noundef readnone [[GENP:%.*]], ptr addrspace(1) [[GP:%.*]], ptr addrspace(3) [[SP:%.*]], ptr addrspace(4) [[CP:%.*]], ptr addrspace(5) [[LP:%.*]]) local_unnamed_addr {
-; CHECK-NEXT:  [[ENTRY:.*:]]
-; CHECK-NEXT:    [[GEN0:%.*]] = tail call i1 @llvm.nvvm.isspacep.const(ptr [[GENP]])
-; CHECK-NEXT:    [[STOREDV:%.*]] = zext i1 [[GEN0]] to i8
-; CHECK-NEXT:    store i8 [[STOREDV]], ptr addrspacecast (ptr addrspace(1) @gen to ptr), align 1
-; CHECK-NEXT:    store i8 0, ptr addrspacecast (ptr addrspace(1) @g1 to ptr), align 1
-; CHECK-NEXT:    store i8 0, ptr addrspacecast (ptr addrspace(1) @g2 to ptr), align 1
-; CHECK-NEXT:    store i8 0, ptr addrspacecast (ptr addrspace(1) @s1 to ptr), align 1
-; CHECK-NEXT:    store i8 0, ptr addrspacecast (ptr addrspace(1) @s2 to ptr), align 1
-; CHECK-NEXT:    store i8 1, ptr addrspacecast (ptr addrspace(1) @c1 to ptr), align 1
-; CHECK-NEXT:    store i8 1, ptr addrspacecast (ptr addrspace(1) @c2 to ptr), align 1
-; CHECK-NEXT:    store i8 0, ptr addrspacecast (ptr addrspace(1) @l to ptr), align 1
-; CHECK-NEXT:    ret void
-;
-  ptr addrspace(1) %gp,
-  ptr addrspace(3) %sp,
-  ptr addrspace(4) %cp,
-  ptr addrspace(5) %lp) local_unnamed_addr {
-entry:
-  ; No constant folding for generic pointers of unknown origin.
-  %gen0 = tail call i1 @llvm.nvvm.isspacep.const(ptr %genp)
-  %storedv = zext i1 %gen0 to i8
-  store i8 %storedv, ptr addrspacecast (ptr addrspace(1) @gen to ptr), align 1
-
-  %isg1 = tail call i1 @llvm.nvvm.isspacep.const(ptr addrspacecast (ptr addrspace(1) @global_data to ptr))
-  %isg18 = zext i1 %isg1 to i8
-  store i8 %isg18, ptr addrspacecast (ptr addrspace(1) @g1 to ptr), align 1
-
-  %gp_asc = addrspacecast ptr addrspace(1) %gp to ptr
-  %isg2 = tail call i1 @llvm.nvvm.isspacep.const(ptr %gp_asc)
-  %isg28 = zext i1 %isg2 to i8
-  store i8 %isg28, ptr addrspacecast (ptr addrspace(1) @g2 to ptr), align 1
-
-  %iss1 = tail call i1 @llvm.nvvm.isspacep.const(ptr addrspacecast (ptr addrspace(3) @shared_data to ptr))
-  %iss18 = zext i1 %iss1 to i8
-  store i8 %iss18, ptr addrspacecast (ptr addrspace(1) @s1 to ptr), align 1
-
-  %sp_asc = addrspacecast ptr addrspace(3) %sp to ptr
-  %iss2 = tail call i1 @llvm.nvvm.isspacep.const(ptr %sp_asc)
-  %iss28 = zext i1 %iss2 to i8
-  store i8 %iss28, ptr addrspacecast (ptr addrspace(1) @s2 to ptr), align 1
-
-  %isc1 = tail call i1 @llvm.nvvm.isspacep.const(ptr addrspacecast (ptr addrspace(4) @const_data to ptr))
-  %isc18 = zext i1 %isc1 to i8
-  store i8 %isc18, ptr addrspacecast (ptr addrspace(1) @c1 to ptr), align 1
-
-  %cp_asc = addrspacecast ptr addrspace(4) %cp to ptr
-  %isc2 = tail call i1 @llvm.nvvm.isspacep.const(ptr %cp_asc)
-  %isc28 = zext i1 %isc2 to i8
-  store i8 %isc28, ptr addrspacecast (ptr addrspace(1) @c2 to ptr), align 1
-
-  ; Local data can't have a constant address, so we can't have a constant ASC expression
-  ; We can only use an ASC instruction.
-  %lp_asc = addrspacecast ptr addrspace(5) %lp to ptr
-  %isl = call i1 @llvm.nvvm.isspacep.const(ptr nonnull %lp_asc)
-  %isl8 = zext i1 %isl to i8
-  store i8 %isl8, ptr addrspacecast (ptr addrspace(1) @l to ptr), align 1
-
-  ret void
-}
-
-define dso_local void @check_local(ptr nocapture noundef readnone %out, ptr nocapture noundef readnone %genp,
-; CHECK-LABEL: define dso_local void @check_local(
-; CHECK-SAME: ptr nocapture noundef readnone [[OUT:%.*]], ptr nocapture noundef readnone [[GENP:%.*]], ptr addrspace(1) [[GP:%.*]], ptr addrspace(3) [[SP:%.*]], ptr addrspace(4) [[CP:%.*]], ptr addrspace(5) [[LP:%.*]]) local_unnamed_addr {
-; CHECK-NEXT:  [[ENTRY:.*:]]
-; CHECK-NEXT:    [[GEN0:%.*]] = tail call i1 @llvm.nvvm.isspacep.local(ptr [[GENP]])
-; CHECK-NEXT:    [[STOREDV:%.*]] = zext i1 [[GEN0]] to i8
-; CHECK-NEXT:    store i8 [[STOREDV]], ptr addrspacecast (ptr addrspace(1) @gen to ptr), align 1
-; CHECK-NEXT:    store i8 0, ptr addrspacecast (ptr addrspace(1) @g1 to ptr), align 1
-; CHECK-NEXT:    store i8 0, ptr addrspacecast (ptr addrspace(1) @g2 to ptr), align 1
-; CHECK-NEXT:    store i8 0, ptr addrspacecast (ptr addrspace(1) @s1 to ptr), align 1
-; CHECK-NEXT:    store i8 0, ptr addrspacecast (ptr addrspace(1) @s2 to ptr), align 1
-; CHECK-NEXT:    store i8 0, ptr addrspacecast (ptr addrspace(1) @c1 to ptr), align 1
-; CHECK-NEXT:    store i8 0, ptr addrspacecast (ptr addrspace(1) @c2 to ptr), align 1
-; CHECK-NEXT:    store i8 1, ptr addrspacecast (ptr addrspace(1) @l to ptr), align 1
-; CHECK-NEXT:    ret void
-;
-  ptr addrspace(1) %gp,
-  ptr addrspace(3) %sp,
-  ptr addrspace(4) %cp,
-  ptr addrspace(5) %lp) local_unnamed_addr {
-entry:
-  ; No constant folding for generic pointers of unknown origin.
-  %gen0 = tail call i1 @llvm.nvvm.isspacep.local(ptr %genp)
-  %storedv = zext i1 %gen0 to i8
-  store i8 %storedv, ptr addrspacecast (ptr addrspace(1) @gen to ptr), align 1
-
-  %isg1 = tail call i1 @llvm.nvvm.isspacep.local(ptr addrspacecast (ptr addrspace(1) @global_data to ptr))
-  %isg18 = zext i1 %isg1 to i8
-  store i8 %isg18, ptr addrspacecast (ptr addrspace(1) @g1 to ptr), align 1
-
-  %gp_asc = addrspacecast ptr addrspace(1) %gp to ptr
-  %isg2 = tail call i1 @llvm.nvvm.isspacep.local(ptr %gp_asc)
-  %isg28 = zext i1 %isg2 to i8
-  store i8 %isg28, ptr addrspacecast (ptr addrspace(1) @g2 to ptr), align 1
-
-  %iss1 = tail call i1 @llvm.nvvm.isspacep.local(ptr addrspacecast (ptr addrspace(3) @shared_data to ptr))
-  %iss18 = zext i1 %iss1 to i8
-  store i8 %iss18, ptr addrspacecast (ptr addrspace(1) @s1 to ptr), align 1
-
-  %sp_asc = addrspacecast ptr addrspace(3) %sp to ptr
-  %iss2 = tail call i1 @llvm.nvvm.isspacep.local(ptr %sp_asc)
-  %iss28 = zext i1 %iss2 to i8
-  store i8 %iss28, ptr addrspacecast (ptr addrspace(1) @s2 to ptr), align 1
-
-  %isc1 = tail call i1 @llvm.nvvm.isspacep.local(ptr addrspacecast (ptr addrspace(4) @const_data to ptr))
-  %isc18 = zext i1 %isc1 to i8
-  store i8 %isc18, ptr addrspacecast (ptr addrspace(1) @c1 to ptr), align 1
-
-  %cp_asc = addrspacecast ptr addrspace(4) %cp to ptr
-  %isc2 = tail call i1 @llvm.nvvm.isspacep.local(ptr %cp_asc)
-  %isc28 = zext i1 %isc2 to i8
-  store i8 %isc28, ptr addrspacecast (ptr addrspace(1) @c2 to ptr), align 1
-
-  ; Local data can't have a constant address, so we can't have a constant ASC expression
-  ; We can only use an ASC instruction.
-  %lp_asc = addrspacecast ptr addrspace(5) %lp to ptr
-  %isl = call i1 @llvm.nvvm.isspacep.local(ptr nonnull %lp_asc)
-  %isl8 = zext i1 %isl to i8
-  store i8 %isl8, ptr addrspacecast (ptr addrspace(1) @l to ptr), align 1
-
-  ret void
-}
-
diff -ruN --strip-trailing-cr a/llvm/test/Transforms/PGOProfile/instr-gen-cold-function.ll b/llvm/test/Transforms/PGOProfile/instr-gen-cold-function.ll
--- a/llvm/test/Transforms/PGOProfile/instr-gen-cold-function.ll
+++ b/llvm/test/Transforms/PGOProfile/instr-gen-cold-function.ll
@@ -1,35 +0,0 @@
-; RUN: opt < %s  --passes=pgo-instr-gen -pgo-instrument-cold-function-only -pgo-function-entry-coverage -S  | FileCheck --check-prefixes=COLD %s
-; RUN: opt < %s  --passes=pgo-instr-gen -pgo-instrument-cold-function-only -pgo-function-entry-coverage -pgo-cold-instrument-entry-threshold=1 -S  | FileCheck --check-prefixes=ENTRY-COUNT %s
-; RUN: opt < %s  --passes=pgo-instr-gen -pgo-instrument-cold-function-only -pgo-function-entry-coverage -pgo-treat-unknown-as-cold -S  | FileCheck --check-prefixes=UNKNOWN-FUNC %s
-
-; COLD: call void @llvm.instrprof.cover(ptr @__profn_foo, i64  [[#]], i32 1, i32 0)
-; COLD-NOT: __profn_main
-; COLD-NOT: __profn_bar
-
-; ENTRY-COUNT: call void @llvm.instrprof.cover(ptr @__profn_foo, i64  [[#]], i32 1, i32 0)
-; ENTRY-COUNT: call void @llvm.instrprof.cover(ptr @__profn_main, i64 [[#]], i32 1, i32 0)
-
-; UNKNOWN-FUNC: call void @llvm.instrprof.cover(ptr @__profn_bar, i64  [[#]], i32 1, i32 0)
-; UNKNOWN-FUNC: call void @llvm.instrprof.cover(ptr @__profn_foo, i64  [[#]], i32 1, i32 0)
-
-
-target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
-target triple = "x86_64-unknown-linux-gnu"
-
-define void @bar() {
-entry:
-  ret void
-}
-
-define void @foo() !prof !0 {
-entry:
-  ret void
-}
-
-define i32 @main() !prof !1 {
-entry:
-  ret i32 0
-}
-
-!0 = !{!"function_entry_count", i64 0}
-!1 = !{!"function_entry_count", i64 1}
